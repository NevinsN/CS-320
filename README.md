# CS-320
A repository for QA and Testing course, CS-320

Reading through what this prompt asks of me, I can't help but think that the answers it seeks are not from this course alone, but instead from the accrued skills and knowledge throughout this course. At the end of the day, no project is truly done if it does not meet the customer’s requirements, even if that customer is you. Before any software is coded, it is vital that requirements not only be clearly given and understood, but that they be translated into code-speak. Before we start typing, we should know how these requirements should be tested for, and what that means for how the program is built. In theory, the actual coding should be somewhat easy. The customer needs their users to create accounts? Wonderful, that means you’ll have a class for user and each member and method will meet a requirement. I’ve learned that object oriented programming has done wonders in simplifying the approach of a developer. Requirements are first, without question. From there, we can build tests and code to fulfill those requirements.

As for functionality and security, I think constant unit testing is a huge part of that. Ensuring that each puzzle piece is trimmed properly will help us to build a functional app. More clearly, if every part of your code is secure and functional, then the system should be as well. Of course, there are always potential mishaps when you integrate different parts of the system, but that is why we test those too, and then the whole system when we’re done with all that. I think my answer, then, is to not skimp on testing. Hire people that not only can but like to break code. Be glad when they hand your code back, broken and mangled, and realize that it is not where it needs to be yet. Only be glad if they can’t break it because you’ve refined it so well that there is nothing to break. We can’t be perfect, and no code ever really will be, but I think this is key to ensuring that your code is as close as possible.
